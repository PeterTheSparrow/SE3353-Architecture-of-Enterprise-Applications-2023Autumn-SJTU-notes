# 第14讲 MySQL分区

2023.10.09 听完了分区1

> 忘掉谁是你 记住我亦有自己见地
无论你几高 身价亦低过青花瓷器
评核我自己 只顾投资于爱情
困在你小宇宙损失对大世界的好奇
> ——《搜神记》 容祖儿

参考文章：https://blog.csdn.net/frostlulu/article/details/122304238

## 1. 分区的好处

当一个表里面的数据太多了的时候，占用的空间太大，可能就接近磁盘的存储空间，这时候就需要分区，把表的数据拆开（分区），然后让不同分区的数据存储到不同的磁盘上面。

> 这里需要思考的一个问题就是，如果我只是简单地在两个磁盘上都有两张结构完全相同的表，只是把数据分散存在两个节点上，那在逻辑上面它们就不是一张表！它们只是碰巧拥有相同的结构而已。所以我们要做的事情就是，让这些多个节点上存储的东西在逻辑上是一张表！

分区表的优点：
- **提高性能**：由于满足给定WHERE子句的数据只被你存储在一个或多个分区上，这将自动从搜索中排除任何剩余分区，因此某些查询可以得到极大的优化。失去有用性的数据通常可以通过删除仅包含该数据的分区（或多个分区）轻松地从分区表中删除。相反，在某些情况下，通过添加一个或多个新分区来专门存储数据，可以大大简化添加新数据的过程。
- 数据可以跨磁盘/文件系统存储，适合存储大量数据。
- 数据的管理非常方便，以分区为单位操作数据，不会影响其他分区的正常运行。

对于应用来说，**表依然是一个逻辑整体**，但**数据库可以针对不同的数据分区独立执行管理操作**，不影响其他分区的运行。而数据划分的规则即称为分区函数，数据写入表时，会根据运算结果决定写入哪个分区。

此外，**MySQL不支持垂直分区，仅仅支持水平分区**，因为垂直分区不太符合MySQL的设计理念。

## 2. 分区的类型

### 2.1 范围Range分区

指定了某一列或者某几列，根据他们值的范围，然后来分区。

- 区域应该是连续而且不能重复的，通常都是用的LESS THEN（都是小于啊！没有等于），比如<0的分个区，<50的分个区，< MAX_VALUE（这玩意就是保证最后所有最大值都给你包容进去）分个区。
- 不允许用float浮点数。臧老师的ICS告诉我们，浮点数的问题是很多的！因为浮点数是近似表示。
- 如果制定了多列，比如a、b、c，能不能把a的列做一个平方或者函数计算一下处理？不行！**不接受表达式**。
- 多列比较的是向量，比如要比较（a,b,c）(d,e,f)，就比较a和d，比较出来小于的话就小于，比较不出来就是比较b和e，然后同理比较c和f

> 举例：
> 例：定义一个员工表，根据员工ID分区，1\~10号员工一个分区，11\~20号员工一个分区，依次类推，共建立4个分区。

## 2.2 列表List分区

列表分区和范围分区类似，主要区别是list partition的分区范围是预先定义好的一系列值，而不是连续的范围。
- 比如交大有闵行、七宝校区等等就可以根据这些校区的值来确定分区。

> 举例：创建一张员工表按照ID进行分区：
> ```sql
>CREATE TABLE employees (
>    id INT NOT NULL,
>    fname VARCHAR(30),
>    lname VARCHAR(30)
>)
>PARTITION BY LIST(id) (
>    PARTITION p0 VALUES IN (1,3,5,7,9),
>    PARTITION p1 VALUES IN (2,4,6,8,10)
>); 
>```


定义某个列的取值范围，根据取值范围来分区。

不同于Switch语句里面的default，采用list分区假如插入一个不符合分区list的元组，系统会直接报错。如果采用Ignore标识符，插入多个行，有的合法有的不合法，系统会插入合法的，丢弃不合法。

## 2.3 Hash分区

根据用户指定的表达式来处理，比如把学号的数字模3，然后决定是哪一台服务器存储，一般在非负的值上面处理。

特殊情况：线性哈希。

> 线性哈希参考文档：https://www.docs4dev.com/docs/zh/mysql/5.7/reference/partitioning-linear-hash.html

## 2.4 Key分区

Mysql自动根据主键散列。

## 3. 问题处理

NULL处理：如果遇到了NULL数值，这种插入的东西会被放到最小的一个分区里面（范围最低的一个分区）而对于List分区，允许in Null专门创建一个分区；对于Hash分区，null都会被当做0然后送到hash函数里面
调整分区（重新组织分区）：比较耗时间，调整涉及到整个表格
删除分区：如果用的分区规则全是小于，那么删除一个分区就会导致原来存储的数据删除，但是后面新的输入插入进来的时候就会进入正确的分区。
特别提示：不允许drop 分区（通过Hash分区或者key散列的）！一旦drop，那么整个分区的数量就发生变化，那么假如之前是取模运算，现在分区数量改变，所有的存储都要发生大变化！除非重新调整，而且不是用reorginaze，用的语法是coalesce！但是追加可以直接进行！具体原因没有将，有自己的实现！