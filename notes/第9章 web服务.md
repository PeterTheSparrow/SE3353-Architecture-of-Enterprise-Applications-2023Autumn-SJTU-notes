# 第9章 web服务

2023.09.24

## 一、WebService概念

Web Services:
- present the opportunity for real interoperability across hardware, operating systems, programming languages, and applications 提供跨硬件、操作系统、编程语言和应用程序实现真正互操作性的机会

>Web:
>- **access with web protocols**, such as HTTP, FTP, SMTP
>- 相对于IPC（进程间通信），比如java中的RMI（remote method invocation）远程方法调用，或者其他语言中的RPC（远程过程调用），**web的访问能力会强得多**——只有web才能做到说比如美国大学有个服务器，我在中国也可以访问得到。
>
>Services: 
>- independent of implementation **独立于具体的实现**
>- Service解决的是异构的问题（操作系统、编程语言的差异），比如客户端是C#开发的，服务端是java开发的，那为了方便他们之间的交互，我们就要走**纯文本**的路线，大家都能认识。既然是纯文本，那需要一定的格式，SOAP传的数据里面包括了一系列的operation、参数的名称类型，但是数据驱动型的。

## 二、SOAP：简单对象访问协议

`SOAP`：指的是简单对象访问协议，针对API纯文本化传递，例如**规定传递XML**的格式。

`WSDL`：一个自描述的文件，把接口描述成xml的形式（只能XML），这个文件不需要自己写，通过工具生成。会根据接口、参数类型、参数顺序、接口返回的参数类型，全部用xml来表述出来。此外会把operation、服务所在的URL接口的名字写出来。

`binding`是什么呢？比如一个webService可以通过http和ftp，那就有两个`binding`；也就是`binding`是说明怎么访问的。类比老师接受答疑，可以通过腾讯会议也可以通过电话。

> 举例：
>
>一个Java程序访问一个c#扣款的服务：
那么这个java程序就需要把c#扣款的服务的wsdl文件给拿到本地，无论你什么框架（比如spring），你要做两件事：
>1. 根据wsdl文件生成java语言的接口
>2. java程序调用接口，里面有一些操作可以调用，调用之后就可以经过一个proxy代理，翻译成一个soap消息发送到c#扣款的服务
>
>c#扣款的服务接收到soap消息，也是先被一个proxy代理拦截，把soap消息翻译成c#然后调用具体的业务逻辑。产生结果后，又返回给proxy代理，组装成一个soap消息，作为调用结果返回
java端的proxy接收到soap消息，翻译成java的返回结果。
java端成功的获取到返回结果

## 三、SOAP的缺点

**性能不好**！
- 需要一个WSDL的文件，里面需要描述消息传递的格式，有一个外挂文件的方式总的来说是不好，需要额外的东西（自包含是最好的）
- 反复组装和解析SOAP需要消耗大量的时间，需要经过很多的翻译
- 客户端、服务端和API耦合，一旦API发生变化（比如下单参数从四个变成五个），那么WSDL文件就要发生变化，服务端客户端代码都需要重新生成，需要消耗时间资源（代码可维护性变差）
  
因此我们需要**数据驱动型**的方式来，**Restful Web Service**应运而生。

## 四、Restful Web Service

含义：Representational表述性，State状态，Transfer转移，全名**表述性状态转移**。

> ajax + json事实上就是web2.0所谓强调动态内容生成去加载；所以现在我们来看restful web service就比较好理解了：

- 表述性：
  - 所有的数据都是资源（既然是资源，就可以通过统一资源定位符来描述）；至于数据怎么描述，这件事情是客户端做的（不是客户端自己负责，客户端的js脚本当然是从服务器下载下来的，是你开发的）
  - 每一个资源都可以有不同的表现方式（同样的数据，可以呈现为饼图、柱状图、折线图）
  - 每个资源都有自己的独有的URI

> URL: Uniform Resource Locator 统一资源定位符
> URI: Uniform Resource Identifier 统一资源标识符
> 
> URL是URI的特例：URL一定要有页面，但是URI不一定要有页面，比如我要查询一个学生的信息，那么我可以通过`/student/1`来查询，这个URI就是一个资源的表述，但是这个URI不一定要有页面。


- 状态：
  - 指的是客户端的状态，客户端维护自己的状态，服务器是无状态的（这就回到了第一节课说的，如果服务器是有状态的，不同的客户端，我服务器就要维护不同的对象！），客户端自己保存cookie或者localstorage
  - 资源的表示就是客户端的状态（数据在前端表示为表格或者图？）

- 转移：
  - 客户端从一个页面跳到另一个页面，一种表示跳到另一种表示，**客户端的状态/表示可以发生迁移**。
  - 迁移的过程中，客户端只把数据请求回来，然后呈现出来，客户端的页面然后就发生了变化，这就是所谓的表述性状态转移


**Restful Web Service特点：**
1. 典型的客户端、服务端架构，但是是无状态的
2. 客户端和服务端之间传递的都是**数据**（数据！纯的！）
3. 服务端只处理数据，数据的展示完全依赖于客户端

**How to design REST**
1. 通过URL设计
   - developers just need to abstract resources according to URLS
   - we just need to design suitale URLs which directly represent user interface
2. Http based: 
   - GET方法对应读、POST代表创建、PUT代表更新、DELETE代表删除，四个HTTP方法严格对应增删改查
   - 通过Http的返回码表示返回的结果，比如201成功，404代表不存在，500代表服务器内部的错误。

## 五、Web Service的优缺点

【这一板块如果有任何问题，请直接回去看web service的定义】

优点：
- 跨平台，基于XML，json等等
- 自描述：
  1. WSDL就是一个自描述文件，里面包括了一系列的操作
  2. Restful的话就是完全基于URL
- 模块化好，封装的好，不需要关系具体的实现
- 区域访问性质广，可以穿透防火墙

缺点：
- 写代码的效率低，不适合stand-alone应用，soap显然比之间rpc效率低，rest因为传递的是纯数据，数据的解析需要消耗一定的资源
- 性能有一定的降低了：需要把java对象转化为一个纯文本的，或者解析文本作为一个java对象
- 安全性，因为webService的地域性广，就比较容易受到攻击，或者中间人截获了。

## 六、什么时候用web Service

支持跨防火墙的通讯、支持跨防火墙的通信、支持应用集成、支持B2B集成、鼓励重用软件；
不应该使用WS时：独立应用程序、如MS Office（访问范围小）、局域网中的同构应用（都是java接口，直接上java就完事了）：例如COM+或EJB之间的通信（再比如spring访问mysql、redis、kafka、elasticSearch）

## 七、SOA：面向服务的架构

SOA指的是Service-oriented architecture （面向服务的架构）。我们关注的问题是：**我们在系统开发的过程中，异构性和需求的变化是我们永远都会遇到的，那么我们如何让自己的系统去快速响应这些问题呢？就是网上去找别人写好的东西，如果别人写的都是和语言无关的服务，我们就直接拿来集成！**

假如我要构建一个电子书店、里面包括了认证登录系统、财务系统、统计系统、订单系统，这么多系统开发下来很复杂，而且假如我是卖家，卖给了1000个新华书店的用户，然后突然发现某个系统存在漏洞，就要告诉一千个用户，这很麻烦。

所以就有一个新方法、登录系统用第三方的比如百度的，订单系统用第三方的，然后我自己就只做一个集成。如果发现登录系统有bug，就告诉百度的问题，百度只要更新自己的就可以了，我们不用把更新包分发给1000个用户，因为它们都是直接调用百度的服务（**比如你调百度地图，你当然不是把百度的副本放到本地运行，而是调用人家的api**）。这样就可以快速构建一个应用，节约开发成本。

特点：
1. 服务之间松散耦合，也就是是登录系统、财务系统、统计系统、订单系统这些系统通过我开发的中间件联系，而不是producer&consumer之间直接互相通信，这样的好处就是假如我发现登录系统不好或者太贵了，我可以换一下，换之后别的系统也不会受到影响（当然松耦合的代价就是性能会差一点）
2. 位置透明，中介者负责路由
3. 协议独立，从http切换到ftp，但是不要让客户端来实现