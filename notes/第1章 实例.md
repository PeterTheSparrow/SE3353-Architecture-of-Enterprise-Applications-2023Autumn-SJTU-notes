# 应用系统体系架构-2023年秋季


## 1. 实例

### 1.1 填坑：Cookie和Session

> 核心问题是什么呢？
> **Http协议是一种无状态的协议**！也就是说，每次请求都是独立的，服务器并不知道你是谁，你上次请求的信息是什么。
>
> 所以，怎么解决这个问题呢？

- Cookie：客户端浏览器用来保存用户信息的一种机制；当我们通过浏览器进行网页访问的时候，服务器会将一些数据以cookie的形式保存在客户端浏览器上，当下次客户端浏览器再次访问该网站时，会将cookie数据发送给服务器，服务器通过cookie数据来辨别用户身份。（cookie存的是key-value键值对）
- Session：表示一个会话，是属于服务器端的一种容器对象；默认情况下，针对每个浏览器的请求，server都会创建一个session对象，生成一个sessionId，用于标识该session对象，同时将sessionId以cookie的形式发送给客户端浏览器，客户端浏览器再次访问该网站时，会将cookie数据发送给服务器，服务器通过cookie数据来辨别用户身份，从而找到对应的session对象，如果找不到，就会创建一个新的session对象。简单来说，**Session的作用就是帮助我们实现一个有状态的Http协议**。

### 1.2 实例池（对象池）

> "对象池"（Object Pool）是一种设计模式，它是一种用于**管理和重用对象实例**的机制，以提高性能和资源利用率的方式。对象池通常用于减少创建和销毁对象的开销，特别是在对象的创建成本较高或频繁创建和销毁对象可能导致性能下降的情况下。
> 在Java中，对象池通常是一个集合，用于存储和管理多个对象实例。当需要使用对象时，可以从对象池中获取一个可用的对象，而不是每次都创建新的对象。一旦使用完成，可以将对象返回到对象池中，以便稍后重用，而不是立即销毁它。


- 实例池的数量一定有上限的，不可能运行每一个用户上来都能创建一个对象，否则DDos攻击的时候内存直接爆炸。
- 假设我们只能创建两个对象，这样内存就不会爆炸了。那是怎么服务于多个用户呢？
- 假设A用户来了，我们创建一个实例A，然后B来了创建一个B，现在实例池满了。这些实例包括数据现在所在位置都是内存里面！
- C来了之后，根据最近最少使用的算法，把A从内存里面换出，落到硬盘上面，然后创建一个C的实例。
- 这样就哪怕限制了实例的数量，也可以服务多个用户。

因此，**系统尽量要无状态的，避免有状态的服务**。
1. 比如说我们要统计一个网站在线用户的数量，这样所有用户公用的一个域就是count：反应用户数量，这样就是无状态的。（这个状态是公用的，不是每个用户都有一个）
2. 如果是每个人来了以后，每个人的对象都不一样，那么就是有状态的。但是有状态的就需要**针对每个用户单独存储**，占用空间，所以尽可能的少或者避免。

> 所以，我们在spring中如何控制实例数量呢？

### 1.3 Scope：实例对象的数量控制

在Spring框架中，"scope"（作用域）用于定义Spring容器如何管理bean实例的生命周期和可见性。Spring支持不同的bean作用域；可以根据应用程序的需求选择适当的作用域。以下是一些常见的Spring作用域：

1. **Singleton（单例）：** 这是Spring默认的作用域。在单例作用域下，Spring容器只创建一个bean实例，并在应用程序的整个生命周期内重用该实例。这意味着每次请求该bean时，都会返回相同的实例。

2. **Prototype（原型）：** 在原型作用域下，每次请求bean时，Spring容器都会创建一个新的bean实例。这意味着每次请求都会返回一个不同的实例。

3. **Request（请求）：** 这个作用域适用于Web应用程序，每个HTTP请求都会创建一个新的bean实例，每个请求之间的实例不共享。

4. **Session（会话）：** 类似于请求作用域，但在HTTP会话的整个生命周期内创建和维护一个bean实例。不同用户的会话之间的实例不共享。

5. **Global Session（全局会话）：** 仅在分布式Web应用程序中使用，它与会话作用域类似，但在集群环境中，全局会话在多个节点之间共享。

6. **Custom（自定义）：** 您还可以定义自定义的作用域，以满足特定需求。要使用自定义作用域，您需要实现Spring的`org.springframework.beans.factory.config.Scope`接口，并将其配置到Spring容器中。

> 关于scope的理解，详见作业1-计时器。
> **tips**：两个浏览器就是两个进程；两个进程是相互隔离的；所以我们用两个浏览器来模拟两个客户端。

### 1.4 数据库连接的数量

数据库的连接也是池化的！（刚才的实例池是对象池，和这里的连接池不是一个东西！）

> 连接池（Connection Pool）是一种用于管理和重用数据库连接、网络连接或其他资源连接的技术，旨在提高应用程序性能和资源利用率。**连接池通过维护一组已创建的连接实例，并在需要时分配这些连接，以减少创建和销毁连接的开销**。
> 
> 这里的连接池本质是一个线程池，里面是一大堆线程。
> 
> 以下是连接池的工作原理和好处：
> **工作原理：**
> 1. **初始化连接池：** 在应用程序启动时，连接池会初始化一定数量的连接实例，这些连接可以立即使用。
> 2. **连接分配：** 当应用程序需要使用连接时，它向连接池请求一个连接。连接池会检查是否有可用的连接实例，如果有，则分配一个给应用程序。
> 3. **连接使用：** 应用程序使用连接执行数据库查询、网络通信或其他操作。
> 4. **连接释放：** 当应用程序完成连接的使用时，它将连接释放回连接池，而不是立即关闭连接。连接池会重新标记这个连接为可用状态。
> 
> 假如要支持10万用户，需要在连接池里面配置多少数据库连接？

连接池的数量：
$$ connections = ((core\_count * 2) + effective\_spindle\_count)$$

注：
1. $core\_count$：CPU核心数
2. $effective\_spindle\_count$：有效磁盘数

为什么：
- 线程来回切换过程需要时间，假如配很多的数据库连接，会导致很多的线程切换的时间，反而降低效率
- 让数据库连接的数量和CPU核心的数量差不多或者两倍（超线程）的时候，这样线程上下文切换的时候就会少，比较好
- 因为CPU处理完之后，在把内存的东西写硬盘的时候写的过程，CPU是空闲的时候，所以还加上有效的硬盘的数量。

所以假如4核心2硬盘的服务器，就只需要十个数据库连接，就可以为十万的用户服务了！
为什么呢：
- 连接池看的不是客户端的数量，而是机器硬件的配置，让需要获取连接的线程在那里等待，然后逐一处理即可。

那如果有100万用户的时候该怎么办？
- 这时候不应该增加数据库连接的数量，而是应该增加机器的数量，每个机器上有一定数量的数据库的连接！
